Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> program ID PYC paux paux2 mainfunction
Rule 2     programa -> program ID PYC empty mainfunction
Rule 3     paux -> vars
Rule 4     paux -> empty
Rule 5     paux2 -> function
Rule 6     paux2 -> empty
Rule 7     vars -> var type vaux PYC vars
Rule 8     vars -> empty
Rule 9     vaux -> ID
Rule 10    vaux -> ID CORIZQ CTEINT CORDER nextvar
Rule 11    vaux -> ID CORIZQ CTEINT COMA CTEINT CORDER nextvar
Rule 12    nextvar -> COMA vaux
Rule 13    nextvar -> empty
Rule 14    mainfunction -> func main PARIZQ PARDER vars bloque
Rule 15    mainfunction -> func main PARIZQ PARDER bloque
Rule 16    bloque -> LLAVEIZQ bloqueaux LLAVEDER
Rule 17    bloque -> LLAVEIZQ empty LLAVEDER
Rule 18    bloqueaux -> estatuto bloqueaux
Rule 19    bloqueaux -> estatuto
Rule 20    type -> int
Rule 21    type -> float
Rule 22    type -> string
Rule 23    function -> type ID PARIZQ funcaux PARDER vars bloque
Rule 24    function -> type ID PARIZQ empty PARDER vars bloque
Rule 25    funcaux -> type ID
Rule 26    funcaux -> type ID COMA funcaux
Rule 27    estatuto -> asignacion
Rule 28    estatuto -> escritura
Rule 29    estatuto -> llamada
Rule 30    estatuto -> condicion
Rule 31    estatuto -> whileloop
Rule 32    estatuto -> forloop
Rule 33    estatuto -> lectura
Rule 34    asignacion -> ID asignaux ASIGNA hyper_exp PYC
Rule 35    asignaux -> CORIZQ expresion CORDER
Rule 36    asignaux -> CORIZQ expresion COMA expresion CORDER
Rule 37    asignaux -> empty
Rule 38    escritura -> print PARIZQ escaux PARDER PYC
Rule 39    escaux -> expresion nextexp
Rule 40    escaux -> CTESTRING nextexp
Rule 41    nextexp -> COMA expresion
Rule 42    nextexp -> empty
Rule 43    llamada -> ID PARIZQ expresion nextexp PARDER
Rule 44    llamada -> ID PARIZQ PARDER
Rule 45    condicion -> if PARIZQ expresion PARDER bloque
Rule 46    condicion -> if PARIZQ expresion PARDER bloque else bloque
Rule 47    whileloop -> while PARIZQ expresion PARDER bloque
Rule 48    forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque
Rule 49    lectura -> input PARIZQ ID PARDER PYC
Rule 50    expresion -> term
Rule 51    expresion -> term MAS term
Rule 52    expresion -> term MENOS term
Rule 53    term -> fact
Rule 54    term -> fact MULT fact
Rule 55    term -> fact DIV fact
Rule 56    fact -> varcte
Rule 57    fact -> varcte PARIZQ hyper_exp PARDER fact
Rule 58    varcte -> CTEINT
Rule 59    varcte -> CTEFLOAT
Rule 60    varcte -> ID
Rule 61    hyper_exp -> super_exp
Rule 62    hyper_exp -> super_exp AND super_exp
Rule 63    hyper_exp -> super_exp OR super_exp
Rule 64    super_exp -> expresion
Rule 65    super_exp -> expresion MAYORQUE expresion
Rule 66    super_exp -> expresion MENORQUE expresion
Rule 67    super_exp -> expresion EQUALS expresion
Rule 68    super_exp -> expresion DIFERENTE expresion
Rule 69    empty -> <empty>

Terminals, with rules where they appear

AND                  : 62
ASIGNA               : 34
COMA                 : 11 12 26 36 41
CORDER               : 10 11 35 36
CORIZQ               : 10 11 35 36
CTEFLOAT             : 59
CTEINT               : 10 11 11 48 48 58
CTESTRING            : 40
DIFERENTE            : 68
DIV                  : 55
DOSPUNTOS            : 48
EQUALS               : 67
ID                   : 1 2 9 10 11 23 24 25 26 34 43 44 49 60
LLAVEDER             : 16 17
LLAVEIZQ             : 16 17
MAS                  : 51
MAYORQUE             : 65
MENORQUE             : 66
MENOS                : 52
MULT                 : 54
OR                   : 63
PARDER               : 14 15 23 24 38 43 44 45 46 47 48 49 57
PARIZQ               : 14 15 23 24 38 43 44 45 46 47 48 49 57
PYC                  : 1 2 7 34 38 49
else                 : 46
error                : 
float                : 21
for                  : 48
func                 : 14 15
if                   : 45 46
input                : 49
int                  : 20
main                 : 14 15
print                : 38
program              : 1 2
string               : 22
var                  : 7
while                : 47

Nonterminals, with rules where they appear

asignacion           : 27
asignaux             : 34
bloque               : 14 15 23 24 45 46 46 47 48
bloqueaux            : 16 18
condicion            : 30
empty                : 2 4 6 8 13 17 24 37 42
escaux               : 38
escritura            : 28
estatuto             : 18 19
expresion            : 35 36 36 39 41 43 45 46 47 64 65 65 66 66 67 67 68 68
fact                 : 53 54 54 55 55 57
forloop              : 32
funcaux              : 23 26
function             : 5
hyper_exp            : 34 57
lectura              : 33
llamada              : 29
mainfunction         : 1 2
nextexp              : 39 40 43
nextvar              : 10 11
paux                 : 1
paux2                : 1
programa             : 0
super_exp            : 61 62 62 63 63
term                 : 50 51 51 52 52
type                 : 7 23 24 25 26
varcte               : 56 57
vars                 : 3 7 14 23 24
vaux                 : 7 12
whileloop            : 31

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . program ID PYC paux paux2 mainfunction
    (2) programa -> . program ID PYC empty mainfunction

    program         shift and go to state 2

    programa                       shift and go to state 1

state 1

    (0) S' -> programa .



state 2

    (1) programa -> program . ID PYC paux paux2 mainfunction
    (2) programa -> program . ID PYC empty mainfunction

    ID              shift and go to state 3


state 3

    (1) programa -> program ID . PYC paux paux2 mainfunction
    (2) programa -> program ID . PYC empty mainfunction

    PYC             shift and go to state 4


state 4

    (1) programa -> program ID PYC . paux paux2 mainfunction
    (2) programa -> program ID PYC . empty mainfunction
    (3) paux -> . vars
    (4) paux -> . empty
    (69) empty -> .
    (7) vars -> . var type vaux PYC vars
    (8) vars -> . empty

    func            reduce using rule 69 (empty -> .)
    int             reduce using rule 69 (empty -> .)
    float           reduce using rule 69 (empty -> .)
    string          reduce using rule 69 (empty -> .)
    var             shift and go to state 8

    paux                           shift and go to state 5
    empty                          shift and go to state 6
    vars                           shift and go to state 7

state 5

    (1) programa -> program ID PYC paux . paux2 mainfunction
    (5) paux2 -> . function
    (6) paux2 -> . empty
    (23) function -> . type ID PARIZQ funcaux PARDER vars bloque
    (24) function -> . type ID PARIZQ empty PARDER vars bloque
    (69) empty -> .
    (20) type -> . int
    (21) type -> . float
    (22) type -> . string

    func            reduce using rule 69 (empty -> .)
    int             shift and go to state 13
    float           shift and go to state 14
    string          shift and go to state 15

    paux2                          shift and go to state 9
    function                       shift and go to state 10
    empty                          shift and go to state 11
    type                           shift and go to state 12

state 6

    (2) programa -> program ID PYC empty . mainfunction
    (4) paux -> empty .
    (8) vars -> empty .
    (14) mainfunction -> . func main PARIZQ PARDER vars bloque
    (15) mainfunction -> . func main PARIZQ PARDER bloque

  ! reduce/reduce conflict for int resolved using rule 4 (paux -> empty .)
  ! reduce/reduce conflict for float resolved using rule 4 (paux -> empty .)
  ! reduce/reduce conflict for string resolved using rule 4 (paux -> empty .)
  ! reduce/reduce conflict for func resolved using rule 4 (paux -> empty .)
  ! shift/reduce conflict for func resolved as shift
    int             reduce using rule 4 (paux -> empty .)
    float           reduce using rule 4 (paux -> empty .)
    string          reduce using rule 4 (paux -> empty .)
    func            shift and go to state 17

  ! func            [ reduce using rule 4 (paux -> empty .) ]
  ! int             [ reduce using rule 8 (vars -> empty .) ]
  ! float           [ reduce using rule 8 (vars -> empty .) ]
  ! string          [ reduce using rule 8 (vars -> empty .) ]
  ! func            [ reduce using rule 8 (vars -> empty .) ]

    mainfunction                   shift and go to state 16

state 7

    (3) paux -> vars .

    int             reduce using rule 3 (paux -> vars .)
    float           reduce using rule 3 (paux -> vars .)
    string          reduce using rule 3 (paux -> vars .)
    func            reduce using rule 3 (paux -> vars .)


state 8

    (7) vars -> var . type vaux PYC vars
    (20) type -> . int
    (21) type -> . float
    (22) type -> . string

    int             shift and go to state 13
    float           shift and go to state 14
    string          shift and go to state 15

    type                           shift and go to state 18

state 9

    (1) programa -> program ID PYC paux paux2 . mainfunction
    (14) mainfunction -> . func main PARIZQ PARDER vars bloque
    (15) mainfunction -> . func main PARIZQ PARDER bloque

    func            shift and go to state 17

    mainfunction                   shift and go to state 19

state 10

    (5) paux2 -> function .

    func            reduce using rule 5 (paux2 -> function .)


state 11

    (6) paux2 -> empty .

    func            reduce using rule 6 (paux2 -> empty .)


state 12

    (23) function -> type . ID PARIZQ funcaux PARDER vars bloque
    (24) function -> type . ID PARIZQ empty PARDER vars bloque

    ID              shift and go to state 20


state 13

    (20) type -> int .

    ID              reduce using rule 20 (type -> int .)


state 14

    (21) type -> float .

    ID              reduce using rule 21 (type -> float .)


state 15

    (22) type -> string .

    ID              reduce using rule 22 (type -> string .)


state 16

    (2) programa -> program ID PYC empty mainfunction .

    $end            reduce using rule 2 (programa -> program ID PYC empty mainfunction .)


state 17

    (14) mainfunction -> func . main PARIZQ PARDER vars bloque
    (15) mainfunction -> func . main PARIZQ PARDER bloque

    main            shift and go to state 21


state 18

    (7) vars -> var type . vaux PYC vars
    (9) vaux -> . ID
    (10) vaux -> . ID CORIZQ CTEINT CORDER nextvar
    (11) vaux -> . ID CORIZQ CTEINT COMA CTEINT CORDER nextvar

    ID              shift and go to state 23

    vaux                           shift and go to state 22

state 19

    (1) programa -> program ID PYC paux paux2 mainfunction .

    $end            reduce using rule 1 (programa -> program ID PYC paux paux2 mainfunction .)


state 20

    (23) function -> type ID . PARIZQ funcaux PARDER vars bloque
    (24) function -> type ID . PARIZQ empty PARDER vars bloque

    PARIZQ          shift and go to state 24


state 21

    (14) mainfunction -> func main . PARIZQ PARDER vars bloque
    (15) mainfunction -> func main . PARIZQ PARDER bloque

    PARIZQ          shift and go to state 25


state 22

    (7) vars -> var type vaux . PYC vars

    PYC             shift and go to state 26


state 23

    (9) vaux -> ID .
    (10) vaux -> ID . CORIZQ CTEINT CORDER nextvar
    (11) vaux -> ID . CORIZQ CTEINT COMA CTEINT CORDER nextvar

    PYC             reduce using rule 9 (vaux -> ID .)
    CORIZQ          shift and go to state 27


state 24

    (23) function -> type ID PARIZQ . funcaux PARDER vars bloque
    (24) function -> type ID PARIZQ . empty PARDER vars bloque
    (25) funcaux -> . type ID
    (26) funcaux -> . type ID COMA funcaux
    (69) empty -> .
    (20) type -> . int
    (21) type -> . float
    (22) type -> . string

    PARDER          reduce using rule 69 (empty -> .)
    int             shift and go to state 13
    float           shift and go to state 14
    string          shift and go to state 15

    type                           shift and go to state 28
    funcaux                        shift and go to state 29
    empty                          shift and go to state 30

state 25

    (14) mainfunction -> func main PARIZQ . PARDER vars bloque
    (15) mainfunction -> func main PARIZQ . PARDER bloque

    PARDER          shift and go to state 31


state 26

    (7) vars -> var type vaux PYC . vars
    (7) vars -> . var type vaux PYC vars
    (8) vars -> . empty
    (69) empty -> .

    var             shift and go to state 8
    int             reduce using rule 69 (empty -> .)
    float           reduce using rule 69 (empty -> .)
    string          reduce using rule 69 (empty -> .)
    func            reduce using rule 69 (empty -> .)
    LLAVEIZQ        reduce using rule 69 (empty -> .)

    vars                           shift and go to state 32
    empty                          shift and go to state 33

state 27

    (10) vaux -> ID CORIZQ . CTEINT CORDER nextvar
    (11) vaux -> ID CORIZQ . CTEINT COMA CTEINT CORDER nextvar

    CTEINT          shift and go to state 34


state 28

    (25) funcaux -> type . ID
    (26) funcaux -> type . ID COMA funcaux

    ID              shift and go to state 35


state 29

    (23) function -> type ID PARIZQ funcaux . PARDER vars bloque

    PARDER          shift and go to state 36


state 30

    (24) function -> type ID PARIZQ empty . PARDER vars bloque

    PARDER          shift and go to state 37


state 31

    (14) mainfunction -> func main PARIZQ PARDER . vars bloque
    (15) mainfunction -> func main PARIZQ PARDER . bloque
    (7) vars -> . var type vaux PYC vars
    (8) vars -> . empty
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER
    (69) empty -> .

  ! shift/reduce conflict for LLAVEIZQ resolved as shift
    var             shift and go to state 8
    LLAVEIZQ        shift and go to state 40

  ! LLAVEIZQ        [ reduce using rule 69 (empty -> .) ]

    vars                           shift and go to state 38
    bloque                         shift and go to state 39
    empty                          shift and go to state 33

state 32

    (7) vars -> var type vaux PYC vars .

    int             reduce using rule 7 (vars -> var type vaux PYC vars .)
    float           reduce using rule 7 (vars -> var type vaux PYC vars .)
    string          reduce using rule 7 (vars -> var type vaux PYC vars .)
    func            reduce using rule 7 (vars -> var type vaux PYC vars .)
    LLAVEIZQ        reduce using rule 7 (vars -> var type vaux PYC vars .)


state 33

    (8) vars -> empty .

    int             reduce using rule 8 (vars -> empty .)
    float           reduce using rule 8 (vars -> empty .)
    string          reduce using rule 8 (vars -> empty .)
    func            reduce using rule 8 (vars -> empty .)
    LLAVEIZQ        reduce using rule 8 (vars -> empty .)


state 34

    (10) vaux -> ID CORIZQ CTEINT . CORDER nextvar
    (11) vaux -> ID CORIZQ CTEINT . COMA CTEINT CORDER nextvar

    CORDER          shift and go to state 41
    COMA            shift and go to state 42


state 35

    (25) funcaux -> type ID .
    (26) funcaux -> type ID . COMA funcaux

    PARDER          reduce using rule 25 (funcaux -> type ID .)
    COMA            shift and go to state 43


state 36

    (23) function -> type ID PARIZQ funcaux PARDER . vars bloque
    (7) vars -> . var type vaux PYC vars
    (8) vars -> . empty
    (69) empty -> .

    var             shift and go to state 8
    LLAVEIZQ        reduce using rule 69 (empty -> .)

    vars                           shift and go to state 44
    empty                          shift and go to state 33

state 37

    (24) function -> type ID PARIZQ empty PARDER . vars bloque
    (7) vars -> . var type vaux PYC vars
    (8) vars -> . empty
    (69) empty -> .

    var             shift and go to state 8
    LLAVEIZQ        reduce using rule 69 (empty -> .)

    empty                          shift and go to state 33
    vars                           shift and go to state 45

state 38

    (14) mainfunction -> func main PARIZQ PARDER vars . bloque
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER

    LLAVEIZQ        shift and go to state 40

    bloque                         shift and go to state 46

state 39

    (15) mainfunction -> func main PARIZQ PARDER bloque .

    $end            reduce using rule 15 (mainfunction -> func main PARIZQ PARDER bloque .)


state 40

    (16) bloque -> LLAVEIZQ . bloqueaux LLAVEDER
    (17) bloque -> LLAVEIZQ . empty LLAVEDER
    (18) bloqueaux -> . estatuto bloqueaux
    (19) bloqueaux -> . estatuto
    (69) empty -> .
    (27) estatuto -> . asignacion
    (28) estatuto -> . escritura
    (29) estatuto -> . llamada
    (30) estatuto -> . condicion
    (31) estatuto -> . whileloop
    (32) estatuto -> . forloop
    (33) estatuto -> . lectura
    (34) asignacion -> . ID asignaux ASIGNA hyper_exp PYC
    (38) escritura -> . print PARIZQ escaux PARDER PYC
    (43) llamada -> . ID PARIZQ expresion nextexp PARDER
    (44) llamada -> . ID PARIZQ PARDER
    (45) condicion -> . if PARIZQ expresion PARDER bloque
    (46) condicion -> . if PARIZQ expresion PARDER bloque else bloque
    (47) whileloop -> . while PARIZQ expresion PARDER bloque
    (48) forloop -> . for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque
    (49) lectura -> . input PARIZQ ID PARDER PYC

    LLAVEDER        reduce using rule 69 (empty -> .)
    ID              shift and go to state 57
    print           shift and go to state 58
    if              shift and go to state 59
    while           shift and go to state 60
    for             shift and go to state 61
    input           shift and go to state 62

    bloqueaux                      shift and go to state 47
    empty                          shift and go to state 48
    estatuto                       shift and go to state 49
    asignacion                     shift and go to state 50
    escritura                      shift and go to state 51
    llamada                        shift and go to state 52
    condicion                      shift and go to state 53
    whileloop                      shift and go to state 54
    forloop                        shift and go to state 55
    lectura                        shift and go to state 56

state 41

    (10) vaux -> ID CORIZQ CTEINT CORDER . nextvar
    (12) nextvar -> . COMA vaux
    (13) nextvar -> . empty
    (69) empty -> .

    COMA            shift and go to state 64
    PYC             reduce using rule 69 (empty -> .)

    nextvar                        shift and go to state 63
    empty                          shift and go to state 65

state 42

    (11) vaux -> ID CORIZQ CTEINT COMA . CTEINT CORDER nextvar

    CTEINT          shift and go to state 66


state 43

    (26) funcaux -> type ID COMA . funcaux
    (25) funcaux -> . type ID
    (26) funcaux -> . type ID COMA funcaux
    (20) type -> . int
    (21) type -> . float
    (22) type -> . string

    int             shift and go to state 13
    float           shift and go to state 14
    string          shift and go to state 15

    type                           shift and go to state 28
    funcaux                        shift and go to state 67

state 44

    (23) function -> type ID PARIZQ funcaux PARDER vars . bloque
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER

    LLAVEIZQ        shift and go to state 40

    bloque                         shift and go to state 68

state 45

    (24) function -> type ID PARIZQ empty PARDER vars . bloque
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER

    LLAVEIZQ        shift and go to state 40

    bloque                         shift and go to state 69

state 46

    (14) mainfunction -> func main PARIZQ PARDER vars bloque .

    $end            reduce using rule 14 (mainfunction -> func main PARIZQ PARDER vars bloque .)


state 47

    (16) bloque -> LLAVEIZQ bloqueaux . LLAVEDER

    LLAVEDER        shift and go to state 70


state 48

    (17) bloque -> LLAVEIZQ empty . LLAVEDER

    LLAVEDER        shift and go to state 71


state 49

    (18) bloqueaux -> estatuto . bloqueaux
    (19) bloqueaux -> estatuto .
    (18) bloqueaux -> . estatuto bloqueaux
    (19) bloqueaux -> . estatuto
    (27) estatuto -> . asignacion
    (28) estatuto -> . escritura
    (29) estatuto -> . llamada
    (30) estatuto -> . condicion
    (31) estatuto -> . whileloop
    (32) estatuto -> . forloop
    (33) estatuto -> . lectura
    (34) asignacion -> . ID asignaux ASIGNA hyper_exp PYC
    (38) escritura -> . print PARIZQ escaux PARDER PYC
    (43) llamada -> . ID PARIZQ expresion nextexp PARDER
    (44) llamada -> . ID PARIZQ PARDER
    (45) condicion -> . if PARIZQ expresion PARDER bloque
    (46) condicion -> . if PARIZQ expresion PARDER bloque else bloque
    (47) whileloop -> . while PARIZQ expresion PARDER bloque
    (48) forloop -> . for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque
    (49) lectura -> . input PARIZQ ID PARDER PYC

    LLAVEDER        reduce using rule 19 (bloqueaux -> estatuto .)
    ID              shift and go to state 57
    print           shift and go to state 58
    if              shift and go to state 59
    while           shift and go to state 60
    for             shift and go to state 61
    input           shift and go to state 62

    estatuto                       shift and go to state 49
    bloqueaux                      shift and go to state 72
    asignacion                     shift and go to state 50
    escritura                      shift and go to state 51
    llamada                        shift and go to state 52
    condicion                      shift and go to state 53
    whileloop                      shift and go to state 54
    forloop                        shift and go to state 55
    lectura                        shift and go to state 56

state 50

    (27) estatuto -> asignacion .

    ID              reduce using rule 27 (estatuto -> asignacion .)
    print           reduce using rule 27 (estatuto -> asignacion .)
    if              reduce using rule 27 (estatuto -> asignacion .)
    while           reduce using rule 27 (estatuto -> asignacion .)
    for             reduce using rule 27 (estatuto -> asignacion .)
    input           reduce using rule 27 (estatuto -> asignacion .)
    LLAVEDER        reduce using rule 27 (estatuto -> asignacion .)


state 51

    (28) estatuto -> escritura .

    ID              reduce using rule 28 (estatuto -> escritura .)
    print           reduce using rule 28 (estatuto -> escritura .)
    if              reduce using rule 28 (estatuto -> escritura .)
    while           reduce using rule 28 (estatuto -> escritura .)
    for             reduce using rule 28 (estatuto -> escritura .)
    input           reduce using rule 28 (estatuto -> escritura .)
    LLAVEDER        reduce using rule 28 (estatuto -> escritura .)


state 52

    (29) estatuto -> llamada .

    ID              reduce using rule 29 (estatuto -> llamada .)
    print           reduce using rule 29 (estatuto -> llamada .)
    if              reduce using rule 29 (estatuto -> llamada .)
    while           reduce using rule 29 (estatuto -> llamada .)
    for             reduce using rule 29 (estatuto -> llamada .)
    input           reduce using rule 29 (estatuto -> llamada .)
    LLAVEDER        reduce using rule 29 (estatuto -> llamada .)


state 53

    (30) estatuto -> condicion .

    ID              reduce using rule 30 (estatuto -> condicion .)
    print           reduce using rule 30 (estatuto -> condicion .)
    if              reduce using rule 30 (estatuto -> condicion .)
    while           reduce using rule 30 (estatuto -> condicion .)
    for             reduce using rule 30 (estatuto -> condicion .)
    input           reduce using rule 30 (estatuto -> condicion .)
    LLAVEDER        reduce using rule 30 (estatuto -> condicion .)


state 54

    (31) estatuto -> whileloop .

    ID              reduce using rule 31 (estatuto -> whileloop .)
    print           reduce using rule 31 (estatuto -> whileloop .)
    if              reduce using rule 31 (estatuto -> whileloop .)
    while           reduce using rule 31 (estatuto -> whileloop .)
    for             reduce using rule 31 (estatuto -> whileloop .)
    input           reduce using rule 31 (estatuto -> whileloop .)
    LLAVEDER        reduce using rule 31 (estatuto -> whileloop .)


state 55

    (32) estatuto -> forloop .

    ID              reduce using rule 32 (estatuto -> forloop .)
    print           reduce using rule 32 (estatuto -> forloop .)
    if              reduce using rule 32 (estatuto -> forloop .)
    while           reduce using rule 32 (estatuto -> forloop .)
    for             reduce using rule 32 (estatuto -> forloop .)
    input           reduce using rule 32 (estatuto -> forloop .)
    LLAVEDER        reduce using rule 32 (estatuto -> forloop .)


state 56

    (33) estatuto -> lectura .

    ID              reduce using rule 33 (estatuto -> lectura .)
    print           reduce using rule 33 (estatuto -> lectura .)
    if              reduce using rule 33 (estatuto -> lectura .)
    while           reduce using rule 33 (estatuto -> lectura .)
    for             reduce using rule 33 (estatuto -> lectura .)
    input           reduce using rule 33 (estatuto -> lectura .)
    LLAVEDER        reduce using rule 33 (estatuto -> lectura .)


state 57

    (34) asignacion -> ID . asignaux ASIGNA hyper_exp PYC
    (43) llamada -> ID . PARIZQ expresion nextexp PARDER
    (44) llamada -> ID . PARIZQ PARDER
    (35) asignaux -> . CORIZQ expresion CORDER
    (36) asignaux -> . CORIZQ expresion COMA expresion CORDER
    (37) asignaux -> . empty
    (69) empty -> .

    PARIZQ          shift and go to state 74
    CORIZQ          shift and go to state 75
    ASIGNA          reduce using rule 69 (empty -> .)

    asignaux                       shift and go to state 73
    empty                          shift and go to state 76

state 58

    (38) escritura -> print . PARIZQ escaux PARDER PYC

    PARIZQ          shift and go to state 77


state 59

    (45) condicion -> if . PARIZQ expresion PARDER bloque
    (46) condicion -> if . PARIZQ expresion PARDER bloque else bloque

    PARIZQ          shift and go to state 78


state 60

    (47) whileloop -> while . PARIZQ expresion PARDER bloque

    PARIZQ          shift and go to state 79


state 61

    (48) forloop -> for . PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque

    PARIZQ          shift and go to state 80


state 62

    (49) lectura -> input . PARIZQ ID PARDER PYC

    PARIZQ          shift and go to state 81


state 63

    (10) vaux -> ID CORIZQ CTEINT CORDER nextvar .

    PYC             reduce using rule 10 (vaux -> ID CORIZQ CTEINT CORDER nextvar .)


state 64

    (12) nextvar -> COMA . vaux
    (9) vaux -> . ID
    (10) vaux -> . ID CORIZQ CTEINT CORDER nextvar
    (11) vaux -> . ID CORIZQ CTEINT COMA CTEINT CORDER nextvar

    ID              shift and go to state 23

    vaux                           shift and go to state 82

state 65

    (13) nextvar -> empty .

    PYC             reduce using rule 13 (nextvar -> empty .)


state 66

    (11) vaux -> ID CORIZQ CTEINT COMA CTEINT . CORDER nextvar

    CORDER          shift and go to state 83


state 67

    (26) funcaux -> type ID COMA funcaux .

    PARDER          reduce using rule 26 (funcaux -> type ID COMA funcaux .)


state 68

    (23) function -> type ID PARIZQ funcaux PARDER vars bloque .

    func            reduce using rule 23 (function -> type ID PARIZQ funcaux PARDER vars bloque .)


state 69

    (24) function -> type ID PARIZQ empty PARDER vars bloque .

    func            reduce using rule 24 (function -> type ID PARIZQ empty PARDER vars bloque .)


state 70

    (16) bloque -> LLAVEIZQ bloqueaux LLAVEDER .

    $end            reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    func            reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    else            reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    ID              reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    print           reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    if              reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    while           reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    for             reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    input           reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)
    LLAVEDER        reduce using rule 16 (bloque -> LLAVEIZQ bloqueaux LLAVEDER .)


state 71

    (17) bloque -> LLAVEIZQ empty LLAVEDER .

    $end            reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    func            reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    else            reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    ID              reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    print           reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    if              reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    while           reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    for             reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    input           reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)
    LLAVEDER        reduce using rule 17 (bloque -> LLAVEIZQ empty LLAVEDER .)


state 72

    (18) bloqueaux -> estatuto bloqueaux .

    LLAVEDER        reduce using rule 18 (bloqueaux -> estatuto bloqueaux .)


state 73

    (34) asignacion -> ID asignaux . ASIGNA hyper_exp PYC

    ASIGNA          shift and go to state 84


state 74

    (43) llamada -> ID PARIZQ . expresion nextexp PARDER
    (44) llamada -> ID PARIZQ . PARDER
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    PARDER          shift and go to state 87
    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 86
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 75

    (35) asignaux -> CORIZQ . expresion CORDER
    (36) asignaux -> CORIZQ . expresion COMA expresion CORDER
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 93
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 76

    (37) asignaux -> empty .

    ASIGNA          reduce using rule 37 (asignaux -> empty .)


state 77

    (38) escritura -> print PARIZQ . escaux PARDER PYC
    (39) escaux -> . expresion nextexp
    (40) escaux -> . CTESTRING nextexp
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTESTRING       shift and go to state 96
    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    escaux                         shift and go to state 94
    expresion                      shift and go to state 95
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 78

    (45) condicion -> if PARIZQ . expresion PARDER bloque
    (46) condicion -> if PARIZQ . expresion PARDER bloque else bloque
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 97
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 79

    (47) whileloop -> while PARIZQ . expresion PARDER bloque
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 98
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 80

    (48) forloop -> for PARIZQ . CTEINT DOSPUNTOS CTEINT PARDER bloque

    CTEINT          shift and go to state 99


state 81

    (49) lectura -> input PARIZQ . ID PARDER PYC

    ID              shift and go to state 100


state 82

    (12) nextvar -> COMA vaux .

    PYC             reduce using rule 12 (nextvar -> COMA vaux .)


state 83

    (11) vaux -> ID CORIZQ CTEINT COMA CTEINT CORDER . nextvar
    (12) nextvar -> . COMA vaux
    (13) nextvar -> . empty
    (69) empty -> .

    COMA            shift and go to state 64
    PYC             reduce using rule 69 (empty -> .)

    nextvar                        shift and go to state 101
    empty                          shift and go to state 65

state 84

    (34) asignacion -> ID asignaux ASIGNA . hyper_exp PYC
    (61) hyper_exp -> . super_exp
    (62) hyper_exp -> . super_exp AND super_exp
    (63) hyper_exp -> . super_exp OR super_exp
    (64) super_exp -> . expresion
    (65) super_exp -> . expresion MAYORQUE expresion
    (66) super_exp -> . expresion MENORQUE expresion
    (67) super_exp -> . expresion EQUALS expresion
    (68) super_exp -> . expresion DIFERENTE expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    hyper_exp                      shift and go to state 102
    super_exp                      shift and go to state 103
    expresion                      shift and go to state 104
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 85

    (60) varcte -> ID .

    PARIZQ          reduce using rule 60 (varcte -> ID .)
    MULT            reduce using rule 60 (varcte -> ID .)
    DIV             reduce using rule 60 (varcte -> ID .)
    MAS             reduce using rule 60 (varcte -> ID .)
    MENOS           reduce using rule 60 (varcte -> ID .)
    COMA            reduce using rule 60 (varcte -> ID .)
    PARDER          reduce using rule 60 (varcte -> ID .)
    CORDER          reduce using rule 60 (varcte -> ID .)
    MAYORQUE        reduce using rule 60 (varcte -> ID .)
    MENORQUE        reduce using rule 60 (varcte -> ID .)
    EQUALS          reduce using rule 60 (varcte -> ID .)
    DIFERENTE       reduce using rule 60 (varcte -> ID .)
    AND             reduce using rule 60 (varcte -> ID .)
    OR              reduce using rule 60 (varcte -> ID .)
    PYC             reduce using rule 60 (varcte -> ID .)


state 86

    (43) llamada -> ID PARIZQ expresion . nextexp PARDER
    (41) nextexp -> . COMA expresion
    (42) nextexp -> . empty
    (69) empty -> .

    COMA            shift and go to state 106
    PARDER          reduce using rule 69 (empty -> .)

    nextexp                        shift and go to state 105
    empty                          shift and go to state 107

state 87

    (44) llamada -> ID PARIZQ PARDER .

    ID              reduce using rule 44 (llamada -> ID PARIZQ PARDER .)
    print           reduce using rule 44 (llamada -> ID PARIZQ PARDER .)
    if              reduce using rule 44 (llamada -> ID PARIZQ PARDER .)
    while           reduce using rule 44 (llamada -> ID PARIZQ PARDER .)
    for             reduce using rule 44 (llamada -> ID PARIZQ PARDER .)
    input           reduce using rule 44 (llamada -> ID PARIZQ PARDER .)
    LLAVEDER        reduce using rule 44 (llamada -> ID PARIZQ PARDER .)


state 88

    (50) expresion -> term .
    (51) expresion -> term . MAS term
    (52) expresion -> term . MENOS term

    COMA            reduce using rule 50 (expresion -> term .)
    PARDER          reduce using rule 50 (expresion -> term .)
    CORDER          reduce using rule 50 (expresion -> term .)
    MAYORQUE        reduce using rule 50 (expresion -> term .)
    MENORQUE        reduce using rule 50 (expresion -> term .)
    EQUALS          reduce using rule 50 (expresion -> term .)
    DIFERENTE       reduce using rule 50 (expresion -> term .)
    AND             reduce using rule 50 (expresion -> term .)
    OR              reduce using rule 50 (expresion -> term .)
    PYC             reduce using rule 50 (expresion -> term .)
    MAS             shift and go to state 108
    MENOS           shift and go to state 109


state 89

    (53) term -> fact .
    (54) term -> fact . MULT fact
    (55) term -> fact . DIV fact

    MAS             reduce using rule 53 (term -> fact .)
    MENOS           reduce using rule 53 (term -> fact .)
    COMA            reduce using rule 53 (term -> fact .)
    PARDER          reduce using rule 53 (term -> fact .)
    CORDER          reduce using rule 53 (term -> fact .)
    MAYORQUE        reduce using rule 53 (term -> fact .)
    MENORQUE        reduce using rule 53 (term -> fact .)
    EQUALS          reduce using rule 53 (term -> fact .)
    DIFERENTE       reduce using rule 53 (term -> fact .)
    AND             reduce using rule 53 (term -> fact .)
    OR              reduce using rule 53 (term -> fact .)
    PYC             reduce using rule 53 (term -> fact .)
    MULT            shift and go to state 110
    DIV             shift and go to state 111


state 90

    (56) fact -> varcte .
    (57) fact -> varcte . PARIZQ hyper_exp PARDER fact

    MULT            reduce using rule 56 (fact -> varcte .)
    DIV             reduce using rule 56 (fact -> varcte .)
    MAS             reduce using rule 56 (fact -> varcte .)
    MENOS           reduce using rule 56 (fact -> varcte .)
    COMA            reduce using rule 56 (fact -> varcte .)
    PARDER          reduce using rule 56 (fact -> varcte .)
    CORDER          reduce using rule 56 (fact -> varcte .)
    MAYORQUE        reduce using rule 56 (fact -> varcte .)
    MENORQUE        reduce using rule 56 (fact -> varcte .)
    EQUALS          reduce using rule 56 (fact -> varcte .)
    DIFERENTE       reduce using rule 56 (fact -> varcte .)
    AND             reduce using rule 56 (fact -> varcte .)
    OR              reduce using rule 56 (fact -> varcte .)
    PYC             reduce using rule 56 (fact -> varcte .)
    PARIZQ          shift and go to state 112


state 91

    (58) varcte -> CTEINT .

    PARIZQ          reduce using rule 58 (varcte -> CTEINT .)
    MULT            reduce using rule 58 (varcte -> CTEINT .)
    DIV             reduce using rule 58 (varcte -> CTEINT .)
    MAS             reduce using rule 58 (varcte -> CTEINT .)
    MENOS           reduce using rule 58 (varcte -> CTEINT .)
    COMA            reduce using rule 58 (varcte -> CTEINT .)
    PARDER          reduce using rule 58 (varcte -> CTEINT .)
    CORDER          reduce using rule 58 (varcte -> CTEINT .)
    MAYORQUE        reduce using rule 58 (varcte -> CTEINT .)
    MENORQUE        reduce using rule 58 (varcte -> CTEINT .)
    EQUALS          reduce using rule 58 (varcte -> CTEINT .)
    DIFERENTE       reduce using rule 58 (varcte -> CTEINT .)
    AND             reduce using rule 58 (varcte -> CTEINT .)
    OR              reduce using rule 58 (varcte -> CTEINT .)
    PYC             reduce using rule 58 (varcte -> CTEINT .)


state 92

    (59) varcte -> CTEFLOAT .

    PARIZQ          reduce using rule 59 (varcte -> CTEFLOAT .)
    MULT            reduce using rule 59 (varcte -> CTEFLOAT .)
    DIV             reduce using rule 59 (varcte -> CTEFLOAT .)
    MAS             reduce using rule 59 (varcte -> CTEFLOAT .)
    MENOS           reduce using rule 59 (varcte -> CTEFLOAT .)
    COMA            reduce using rule 59 (varcte -> CTEFLOAT .)
    PARDER          reduce using rule 59 (varcte -> CTEFLOAT .)
    CORDER          reduce using rule 59 (varcte -> CTEFLOAT .)
    MAYORQUE        reduce using rule 59 (varcte -> CTEFLOAT .)
    MENORQUE        reduce using rule 59 (varcte -> CTEFLOAT .)
    EQUALS          reduce using rule 59 (varcte -> CTEFLOAT .)
    DIFERENTE       reduce using rule 59 (varcte -> CTEFLOAT .)
    AND             reduce using rule 59 (varcte -> CTEFLOAT .)
    OR              reduce using rule 59 (varcte -> CTEFLOAT .)
    PYC             reduce using rule 59 (varcte -> CTEFLOAT .)


state 93

    (35) asignaux -> CORIZQ expresion . CORDER
    (36) asignaux -> CORIZQ expresion . COMA expresion CORDER

    CORDER          shift and go to state 113
    COMA            shift and go to state 114


state 94

    (38) escritura -> print PARIZQ escaux . PARDER PYC

    PARDER          shift and go to state 115


state 95

    (39) escaux -> expresion . nextexp
    (41) nextexp -> . COMA expresion
    (42) nextexp -> . empty
    (69) empty -> .

    COMA            shift and go to state 106
    PARDER          reduce using rule 69 (empty -> .)

    nextexp                        shift and go to state 116
    empty                          shift and go to state 107

state 96

    (40) escaux -> CTESTRING . nextexp
    (41) nextexp -> . COMA expresion
    (42) nextexp -> . empty
    (69) empty -> .

    COMA            shift and go to state 106
    PARDER          reduce using rule 69 (empty -> .)

    nextexp                        shift and go to state 117
    empty                          shift and go to state 107

state 97

    (45) condicion -> if PARIZQ expresion . PARDER bloque
    (46) condicion -> if PARIZQ expresion . PARDER bloque else bloque

    PARDER          shift and go to state 118


state 98

    (47) whileloop -> while PARIZQ expresion . PARDER bloque

    PARDER          shift and go to state 119


state 99

    (48) forloop -> for PARIZQ CTEINT . DOSPUNTOS CTEINT PARDER bloque

    DOSPUNTOS       shift and go to state 120


state 100

    (49) lectura -> input PARIZQ ID . PARDER PYC

    PARDER          shift and go to state 121


state 101

    (11) vaux -> ID CORIZQ CTEINT COMA CTEINT CORDER nextvar .

    PYC             reduce using rule 11 (vaux -> ID CORIZQ CTEINT COMA CTEINT CORDER nextvar .)


state 102

    (34) asignacion -> ID asignaux ASIGNA hyper_exp . PYC

    PYC             shift and go to state 122


state 103

    (61) hyper_exp -> super_exp .
    (62) hyper_exp -> super_exp . AND super_exp
    (63) hyper_exp -> super_exp . OR super_exp

    PYC             reduce using rule 61 (hyper_exp -> super_exp .)
    PARDER          reduce using rule 61 (hyper_exp -> super_exp .)
    AND             shift and go to state 123
    OR              shift and go to state 124


state 104

    (64) super_exp -> expresion .
    (65) super_exp -> expresion . MAYORQUE expresion
    (66) super_exp -> expresion . MENORQUE expresion
    (67) super_exp -> expresion . EQUALS expresion
    (68) super_exp -> expresion . DIFERENTE expresion

    AND             reduce using rule 64 (super_exp -> expresion .)
    OR              reduce using rule 64 (super_exp -> expresion .)
    PYC             reduce using rule 64 (super_exp -> expresion .)
    PARDER          reduce using rule 64 (super_exp -> expresion .)
    MAYORQUE        shift and go to state 125
    MENORQUE        shift and go to state 126
    EQUALS          shift and go to state 127
    DIFERENTE       shift and go to state 128


state 105

    (43) llamada -> ID PARIZQ expresion nextexp . PARDER

    PARDER          shift and go to state 129


state 106

    (41) nextexp -> COMA . expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 130
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 107

    (42) nextexp -> empty .

    PARDER          reduce using rule 42 (nextexp -> empty .)


state 108

    (51) expresion -> term MAS . term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    term                           shift and go to state 131
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 109

    (52) expresion -> term MENOS . term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    term                           shift and go to state 132
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 110

    (54) term -> fact MULT . fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    fact                           shift and go to state 133
    varcte                         shift and go to state 90

state 111

    (55) term -> fact DIV . fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    fact                           shift and go to state 134
    varcte                         shift and go to state 90

state 112

    (57) fact -> varcte PARIZQ . hyper_exp PARDER fact
    (61) hyper_exp -> . super_exp
    (62) hyper_exp -> . super_exp AND super_exp
    (63) hyper_exp -> . super_exp OR super_exp
    (64) super_exp -> . expresion
    (65) super_exp -> . expresion MAYORQUE expresion
    (66) super_exp -> . expresion MENORQUE expresion
    (67) super_exp -> . expresion EQUALS expresion
    (68) super_exp -> . expresion DIFERENTE expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    varcte                         shift and go to state 90
    hyper_exp                      shift and go to state 135
    fact                           shift and go to state 89
    super_exp                      shift and go to state 103
    expresion                      shift and go to state 104
    term                           shift and go to state 88

state 113

    (35) asignaux -> CORIZQ expresion CORDER .

    ASIGNA          reduce using rule 35 (asignaux -> CORIZQ expresion CORDER .)


state 114

    (36) asignaux -> CORIZQ expresion COMA . expresion CORDER
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 136
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 115

    (38) escritura -> print PARIZQ escaux PARDER . PYC

    PYC             shift and go to state 137


state 116

    (39) escaux -> expresion nextexp .

    PARDER          reduce using rule 39 (escaux -> expresion nextexp .)


state 117

    (40) escaux -> CTESTRING nextexp .

    PARDER          reduce using rule 40 (escaux -> CTESTRING nextexp .)


state 118

    (45) condicion -> if PARIZQ expresion PARDER . bloque
    (46) condicion -> if PARIZQ expresion PARDER . bloque else bloque
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER

    LLAVEIZQ        shift and go to state 40

    bloque                         shift and go to state 138

state 119

    (47) whileloop -> while PARIZQ expresion PARDER . bloque
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER

    LLAVEIZQ        shift and go to state 40

    bloque                         shift and go to state 139

state 120

    (48) forloop -> for PARIZQ CTEINT DOSPUNTOS . CTEINT PARDER bloque

    CTEINT          shift and go to state 140


state 121

    (49) lectura -> input PARIZQ ID PARDER . PYC

    PYC             shift and go to state 141


state 122

    (34) asignacion -> ID asignaux ASIGNA hyper_exp PYC .

    ID              reduce using rule 34 (asignacion -> ID asignaux ASIGNA hyper_exp PYC .)
    print           reduce using rule 34 (asignacion -> ID asignaux ASIGNA hyper_exp PYC .)
    if              reduce using rule 34 (asignacion -> ID asignaux ASIGNA hyper_exp PYC .)
    while           reduce using rule 34 (asignacion -> ID asignaux ASIGNA hyper_exp PYC .)
    for             reduce using rule 34 (asignacion -> ID asignaux ASIGNA hyper_exp PYC .)
    input           reduce using rule 34 (asignacion -> ID asignaux ASIGNA hyper_exp PYC .)
    LLAVEDER        reduce using rule 34 (asignacion -> ID asignaux ASIGNA hyper_exp PYC .)


state 123

    (62) hyper_exp -> super_exp AND . super_exp
    (64) super_exp -> . expresion
    (65) super_exp -> . expresion MAYORQUE expresion
    (66) super_exp -> . expresion MENORQUE expresion
    (67) super_exp -> . expresion EQUALS expresion
    (68) super_exp -> . expresion DIFERENTE expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    super_exp                      shift and go to state 142
    expresion                      shift and go to state 104
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 124

    (63) hyper_exp -> super_exp OR . super_exp
    (64) super_exp -> . expresion
    (65) super_exp -> . expresion MAYORQUE expresion
    (66) super_exp -> . expresion MENORQUE expresion
    (67) super_exp -> . expresion EQUALS expresion
    (68) super_exp -> . expresion DIFERENTE expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    super_exp                      shift and go to state 143
    expresion                      shift and go to state 104
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 125

    (65) super_exp -> expresion MAYORQUE . expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 144
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 126

    (66) super_exp -> expresion MENORQUE . expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 145
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 127

    (67) super_exp -> expresion EQUALS . expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 146
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 128

    (68) super_exp -> expresion DIFERENTE . expresion
    (50) expresion -> . term
    (51) expresion -> . term MAS term
    (52) expresion -> . term MENOS term
    (53) term -> . fact
    (54) term -> . fact MULT fact
    (55) term -> . fact DIV fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    expresion                      shift and go to state 147
    term                           shift and go to state 88
    fact                           shift and go to state 89
    varcte                         shift and go to state 90

state 129

    (43) llamada -> ID PARIZQ expresion nextexp PARDER .

    ID              reduce using rule 43 (llamada -> ID PARIZQ expresion nextexp PARDER .)
    print           reduce using rule 43 (llamada -> ID PARIZQ expresion nextexp PARDER .)
    if              reduce using rule 43 (llamada -> ID PARIZQ expresion nextexp PARDER .)
    while           reduce using rule 43 (llamada -> ID PARIZQ expresion nextexp PARDER .)
    for             reduce using rule 43 (llamada -> ID PARIZQ expresion nextexp PARDER .)
    input           reduce using rule 43 (llamada -> ID PARIZQ expresion nextexp PARDER .)
    LLAVEDER        reduce using rule 43 (llamada -> ID PARIZQ expresion nextexp PARDER .)


state 130

    (41) nextexp -> COMA expresion .

    PARDER          reduce using rule 41 (nextexp -> COMA expresion .)


state 131

    (51) expresion -> term MAS term .

    COMA            reduce using rule 51 (expresion -> term MAS term .)
    PARDER          reduce using rule 51 (expresion -> term MAS term .)
    CORDER          reduce using rule 51 (expresion -> term MAS term .)
    MAYORQUE        reduce using rule 51 (expresion -> term MAS term .)
    MENORQUE        reduce using rule 51 (expresion -> term MAS term .)
    EQUALS          reduce using rule 51 (expresion -> term MAS term .)
    DIFERENTE       reduce using rule 51 (expresion -> term MAS term .)
    AND             reduce using rule 51 (expresion -> term MAS term .)
    OR              reduce using rule 51 (expresion -> term MAS term .)
    PYC             reduce using rule 51 (expresion -> term MAS term .)


state 132

    (52) expresion -> term MENOS term .

    COMA            reduce using rule 52 (expresion -> term MENOS term .)
    PARDER          reduce using rule 52 (expresion -> term MENOS term .)
    CORDER          reduce using rule 52 (expresion -> term MENOS term .)
    MAYORQUE        reduce using rule 52 (expresion -> term MENOS term .)
    MENORQUE        reduce using rule 52 (expresion -> term MENOS term .)
    EQUALS          reduce using rule 52 (expresion -> term MENOS term .)
    DIFERENTE       reduce using rule 52 (expresion -> term MENOS term .)
    AND             reduce using rule 52 (expresion -> term MENOS term .)
    OR              reduce using rule 52 (expresion -> term MENOS term .)
    PYC             reduce using rule 52 (expresion -> term MENOS term .)


state 133

    (54) term -> fact MULT fact .

    MAS             reduce using rule 54 (term -> fact MULT fact .)
    MENOS           reduce using rule 54 (term -> fact MULT fact .)
    COMA            reduce using rule 54 (term -> fact MULT fact .)
    PARDER          reduce using rule 54 (term -> fact MULT fact .)
    CORDER          reduce using rule 54 (term -> fact MULT fact .)
    MAYORQUE        reduce using rule 54 (term -> fact MULT fact .)
    MENORQUE        reduce using rule 54 (term -> fact MULT fact .)
    EQUALS          reduce using rule 54 (term -> fact MULT fact .)
    DIFERENTE       reduce using rule 54 (term -> fact MULT fact .)
    AND             reduce using rule 54 (term -> fact MULT fact .)
    OR              reduce using rule 54 (term -> fact MULT fact .)
    PYC             reduce using rule 54 (term -> fact MULT fact .)


state 134

    (55) term -> fact DIV fact .

    MAS             reduce using rule 55 (term -> fact DIV fact .)
    MENOS           reduce using rule 55 (term -> fact DIV fact .)
    COMA            reduce using rule 55 (term -> fact DIV fact .)
    PARDER          reduce using rule 55 (term -> fact DIV fact .)
    CORDER          reduce using rule 55 (term -> fact DIV fact .)
    MAYORQUE        reduce using rule 55 (term -> fact DIV fact .)
    MENORQUE        reduce using rule 55 (term -> fact DIV fact .)
    EQUALS          reduce using rule 55 (term -> fact DIV fact .)
    DIFERENTE       reduce using rule 55 (term -> fact DIV fact .)
    AND             reduce using rule 55 (term -> fact DIV fact .)
    OR              reduce using rule 55 (term -> fact DIV fact .)
    PYC             reduce using rule 55 (term -> fact DIV fact .)


state 135

    (57) fact -> varcte PARIZQ hyper_exp . PARDER fact

    PARDER          shift and go to state 148


state 136

    (36) asignaux -> CORIZQ expresion COMA expresion . CORDER

    CORDER          shift and go to state 149


state 137

    (38) escritura -> print PARIZQ escaux PARDER PYC .

    ID              reduce using rule 38 (escritura -> print PARIZQ escaux PARDER PYC .)
    print           reduce using rule 38 (escritura -> print PARIZQ escaux PARDER PYC .)
    if              reduce using rule 38 (escritura -> print PARIZQ escaux PARDER PYC .)
    while           reduce using rule 38 (escritura -> print PARIZQ escaux PARDER PYC .)
    for             reduce using rule 38 (escritura -> print PARIZQ escaux PARDER PYC .)
    input           reduce using rule 38 (escritura -> print PARIZQ escaux PARDER PYC .)
    LLAVEDER        reduce using rule 38 (escritura -> print PARIZQ escaux PARDER PYC .)


state 138

    (45) condicion -> if PARIZQ expresion PARDER bloque .
    (46) condicion -> if PARIZQ expresion PARDER bloque . else bloque

    ID              reduce using rule 45 (condicion -> if PARIZQ expresion PARDER bloque .)
    print           reduce using rule 45 (condicion -> if PARIZQ expresion PARDER bloque .)
    if              reduce using rule 45 (condicion -> if PARIZQ expresion PARDER bloque .)
    while           reduce using rule 45 (condicion -> if PARIZQ expresion PARDER bloque .)
    for             reduce using rule 45 (condicion -> if PARIZQ expresion PARDER bloque .)
    input           reduce using rule 45 (condicion -> if PARIZQ expresion PARDER bloque .)
    LLAVEDER        reduce using rule 45 (condicion -> if PARIZQ expresion PARDER bloque .)
    else            shift and go to state 150


state 139

    (47) whileloop -> while PARIZQ expresion PARDER bloque .

    ID              reduce using rule 47 (whileloop -> while PARIZQ expresion PARDER bloque .)
    print           reduce using rule 47 (whileloop -> while PARIZQ expresion PARDER bloque .)
    if              reduce using rule 47 (whileloop -> while PARIZQ expresion PARDER bloque .)
    while           reduce using rule 47 (whileloop -> while PARIZQ expresion PARDER bloque .)
    for             reduce using rule 47 (whileloop -> while PARIZQ expresion PARDER bloque .)
    input           reduce using rule 47 (whileloop -> while PARIZQ expresion PARDER bloque .)
    LLAVEDER        reduce using rule 47 (whileloop -> while PARIZQ expresion PARDER bloque .)


state 140

    (48) forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT . PARDER bloque

    PARDER          shift and go to state 151


state 141

    (49) lectura -> input PARIZQ ID PARDER PYC .

    ID              reduce using rule 49 (lectura -> input PARIZQ ID PARDER PYC .)
    print           reduce using rule 49 (lectura -> input PARIZQ ID PARDER PYC .)
    if              reduce using rule 49 (lectura -> input PARIZQ ID PARDER PYC .)
    while           reduce using rule 49 (lectura -> input PARIZQ ID PARDER PYC .)
    for             reduce using rule 49 (lectura -> input PARIZQ ID PARDER PYC .)
    input           reduce using rule 49 (lectura -> input PARIZQ ID PARDER PYC .)
    LLAVEDER        reduce using rule 49 (lectura -> input PARIZQ ID PARDER PYC .)


state 142

    (62) hyper_exp -> super_exp AND super_exp .

    PYC             reduce using rule 62 (hyper_exp -> super_exp AND super_exp .)
    PARDER          reduce using rule 62 (hyper_exp -> super_exp AND super_exp .)


state 143

    (63) hyper_exp -> super_exp OR super_exp .

    PYC             reduce using rule 63 (hyper_exp -> super_exp OR super_exp .)
    PARDER          reduce using rule 63 (hyper_exp -> super_exp OR super_exp .)


state 144

    (65) super_exp -> expresion MAYORQUE expresion .

    AND             reduce using rule 65 (super_exp -> expresion MAYORQUE expresion .)
    OR              reduce using rule 65 (super_exp -> expresion MAYORQUE expresion .)
    PYC             reduce using rule 65 (super_exp -> expresion MAYORQUE expresion .)
    PARDER          reduce using rule 65 (super_exp -> expresion MAYORQUE expresion .)


state 145

    (66) super_exp -> expresion MENORQUE expresion .

    AND             reduce using rule 66 (super_exp -> expresion MENORQUE expresion .)
    OR              reduce using rule 66 (super_exp -> expresion MENORQUE expresion .)
    PYC             reduce using rule 66 (super_exp -> expresion MENORQUE expresion .)
    PARDER          reduce using rule 66 (super_exp -> expresion MENORQUE expresion .)


state 146

    (67) super_exp -> expresion EQUALS expresion .

    AND             reduce using rule 67 (super_exp -> expresion EQUALS expresion .)
    OR              reduce using rule 67 (super_exp -> expresion EQUALS expresion .)
    PYC             reduce using rule 67 (super_exp -> expresion EQUALS expresion .)
    PARDER          reduce using rule 67 (super_exp -> expresion EQUALS expresion .)


state 147

    (68) super_exp -> expresion DIFERENTE expresion .

    AND             reduce using rule 68 (super_exp -> expresion DIFERENTE expresion .)
    OR              reduce using rule 68 (super_exp -> expresion DIFERENTE expresion .)
    PYC             reduce using rule 68 (super_exp -> expresion DIFERENTE expresion .)
    PARDER          reduce using rule 68 (super_exp -> expresion DIFERENTE expresion .)


state 148

    (57) fact -> varcte PARIZQ hyper_exp PARDER . fact
    (56) fact -> . varcte
    (57) fact -> . varcte PARIZQ hyper_exp PARDER fact
    (58) varcte -> . CTEINT
    (59) varcte -> . CTEFLOAT
    (60) varcte -> . ID

    CTEINT          shift and go to state 91
    CTEFLOAT        shift and go to state 92
    ID              shift and go to state 85

    varcte                         shift and go to state 90
    fact                           shift and go to state 152

state 149

    (36) asignaux -> CORIZQ expresion COMA expresion CORDER .

    ASIGNA          reduce using rule 36 (asignaux -> CORIZQ expresion COMA expresion CORDER .)


state 150

    (46) condicion -> if PARIZQ expresion PARDER bloque else . bloque
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER

    LLAVEIZQ        shift and go to state 40

    bloque                         shift and go to state 153

state 151

    (48) forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER . bloque
    (16) bloque -> . LLAVEIZQ bloqueaux LLAVEDER
    (17) bloque -> . LLAVEIZQ empty LLAVEDER

    LLAVEIZQ        shift and go to state 40

    bloque                         shift and go to state 154

state 152

    (57) fact -> varcte PARIZQ hyper_exp PARDER fact .

    MULT            reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    DIV             reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    MAS             reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    MENOS           reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    COMA            reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    PARDER          reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    CORDER          reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    MAYORQUE        reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    MENORQUE        reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    EQUALS          reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    DIFERENTE       reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    AND             reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    OR              reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)
    PYC             reduce using rule 57 (fact -> varcte PARIZQ hyper_exp PARDER fact .)


state 153

    (46) condicion -> if PARIZQ expresion PARDER bloque else bloque .

    ID              reduce using rule 46 (condicion -> if PARIZQ expresion PARDER bloque else bloque .)
    print           reduce using rule 46 (condicion -> if PARIZQ expresion PARDER bloque else bloque .)
    if              reduce using rule 46 (condicion -> if PARIZQ expresion PARDER bloque else bloque .)
    while           reduce using rule 46 (condicion -> if PARIZQ expresion PARDER bloque else bloque .)
    for             reduce using rule 46 (condicion -> if PARIZQ expresion PARDER bloque else bloque .)
    input           reduce using rule 46 (condicion -> if PARIZQ expresion PARDER bloque else bloque .)
    LLAVEDER        reduce using rule 46 (condicion -> if PARIZQ expresion PARDER bloque else bloque .)


state 154

    (48) forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .

    ID              reduce using rule 48 (forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .)
    print           reduce using rule 48 (forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .)
    if              reduce using rule 48 (forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .)
    while           reduce using rule 48 (forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .)
    for             reduce using rule 48 (forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .)
    input           reduce using rule 48 (forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .)
    LLAVEDER        reduce using rule 48 (forloop -> for PARIZQ CTEINT DOSPUNTOS CTEINT PARDER bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for func in state 6 resolved as shift
WARNING: shift/reduce conflict for LLAVEIZQ in state 31 resolved as shift
WARNING: reduce/reduce conflict in state 6 resolved using rule (paux -> empty)
WARNING: rejected rule (vars -> empty) in state 6
